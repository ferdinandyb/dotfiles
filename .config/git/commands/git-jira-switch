#!/bin/sh

WORKTREE_MODE=0
PICK_MODE=0
CLEAN_MODE=0

show_help() {
    cat << EOF
Usage: git jira-switch [OPTIONS] <ticket-number> [base-branch]

Create a branch from JIRA ticket information and switch to it.

Requirements:
  - jira CLI tool (https://github.com/ankitpokhrel/jira-cli)
  - fzf (optional, for --pick mode)

Options:
  -w, --worktree        Create a worktree instead of switching branches locally
  -p, --pick            Pick from assigned non-done tickets using fzf
  -c, --clean-worktrees Clean up worktrees for closed/done tickets
  -h, --help            Show this help message

Arguments:
  ticket-number     JIRA ticket number (e.g., PROJ-123)
  base-branch       Optional base branch to branch from (if omitted, 
                    defaults to origin/HEAD with --no-track)

Examples:
  git jira-switch -w -p
  git jira-switch PROJ-123
  git jira-switch --worktree PROJ-123
  git jira-switch --pick
  git jira-switch --pick develop
  git jira-switch --worktree --pick feature/main
  git jira-switch --clean-worktrees
EOF
}

while [ $# -gt 0 ]; do
    case $1 in
        -w|--worktree)
            WORKTREE_MODE=1
            shift
            ;;
        -p|--pick)
            PICK_MODE=1
            shift
            ;;
        -c|--clean-worktrees)
            CLEAN_MODE=1
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "ERROR: Unknown option $1" 1>&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Validate flag combinations
if [ "$CLEAN_MODE" -eq 1 ]; then
    if [ "$WORKTREE_MODE" -eq 1 ] || [ "$PICK_MODE" -eq 1 ] || [ $# -gt 0 ]; then
        echo "ERROR: --clean-worktrees cannot be combined with other options or arguments" 1>&2
        exit 1
    fi
fi

if [ "$CLEAN_MODE" -eq 1 ]; then
    # Clean mode - find and delete worktrees for closed tickets
    echo "Scanning worktrees for closed tickets..."

    # Get all worktrees except the main one
    worktrees=$(git worktree list --porcelain | grep -E "^worktree " | tail -n +2 | cut -d' ' -f2)

    if [ -z "$worktrees" ]; then
        echo "No worktrees found to clean"
        exit 0
    fi

    # Get main repo name for pattern matching
    MAIN_WORKTREE=$(git worktree list --porcelain | head -n 1 | cut -d' ' -f2)
    REPO_NAME=$(basename "$MAIN_WORKTREE")

    worktrees_to_delete=""

    for worktree in $worktrees; do
        worktree_name=$(basename "$worktree")

        # Extract ticket from worktree name pattern: repo-TICKET-123-summary
        pattern="^${REPO_NAME}-[A-Z]\+-[0-9]\+-"

        if echo "$worktree_name" | grep -q "$pattern"; then
            ticket=$(echo "$worktree_name" | grep -o "[A-Z]\+-[0-9]\+" | head -n 1)

            # Check ticket status in JIRA
            project=$(echo "$ticket" | cut -d'-' -f1)
            status=$(jira -p "$project" issue list -q "key = $ticket" --plain --no-headers --columns status 2>/dev/null | awk '{print $2}')

            if [ -n "$status" ] && (echo "$status" | grep -iq "done\|closed\|resolved"); then
                worktrees_to_delete="${worktrees_to_delete}${worktree}\n"
            fi
        fi
    done

    if [ -z "$worktrees_to_delete" ]; then
        echo "No worktrees found with closed tickets"
        exit 0
    fi

    echo "The following worktrees will be deleted:"
    echo ""
    printf "%b" "$worktrees_to_delete"
    echo ""
    printf "Delete these worktrees? (y/N): "
    read -r confirmation

    if [ "$confirmation" = "y" ] || [ "$confirmation" = "Y" ]; then
        printf "%b" "$worktrees_to_delete" | while read -r worktree_path; do
            if [ -n "$worktree_path" ]; then
                echo "Removing worktree: $worktree_path"
                git worktree remove "$worktree_path" --force
            fi
        done
        echo "Cleanup completed"
    else
        echo "Cleanup cancelled"
    fi
    exit 0
elif [ "$PICK_MODE" -eq 1 ]; then
    # In pick mode, first argument is base branch (optional)
    base_branch=$1

    # Get all non-done tickets assigned to current user
    echo "Fetching tickets, please wait."
    jql_query="project IS NOT EMPTY AND assignee = currentUser() AND status NOT IN (Done, Closed, Resolved)"
    tickets=$(jira issue list -q"$jql_query" --plain --no-headers --columns key,summary 2>/dev/null)

    if [ -z "$tickets" ]; then
        echo "ERROR: No assigned non-done tickets found" 1>&2
        exit 1
    fi

    # Check if fzf is available
    if command -v fzf >/dev/null 2>&1; then
        selected=$(echo "$tickets" | fzf --prompt="Select ticket: " --height=40% --reverse --border)
        if [ -z "$selected" ]; then
            echo "No ticket selected"
            exit 0
        fi
        ticket=$(echo "$selected" | awk '{print $1}')
    else
        echo "fzf not found. Available tickets:"
        echo ""
        echo "$tickets"
        echo ""
        echo "Install fzf for interactive selection, or run manually:"
        echo "  git jira-switch <ticket-number>"
        exit 1
    fi
else
    # Normal mode
    ticket=$1
    base_branch=$2
    
    if [ -z "$ticket" ]; then
        echo "ERROR: Please provide the jira ticket number" 1>&2
        echo ""
        show_help
        exit 1
    fi
fi

project=$(echo "$ticket" | cut -d'-' -f1)

jiraBranchName=$(jira -p $project issue list -q "key = $ticket" --plain | awk 'NR==2' | awk -F '\t' '{ print $3 }')
echo ""
if [ -z "$jiraBranchName" ]; then
    echo "ERROR: Please provide valid jira ticket number" 1>&2
    echo ""
    show_help
    exit 1
fi

jirasummary=$(echo "$jiraBranchName" | sed "s/[^[:alpha:].-]/-/g" | tr '[:upper:]' '[:lower:]' | head -c 30)

branchName="$ticket-$jirasummary"

# Set base branch - use provided base_branch if given, otherwise origin/HEAD
if [ -n "$base_branch" ]; then
    base_ref="$base_branch"
    track_flag=""  # Track the specified base branch
else
    base_ref="origin/HEAD"
    track_flag="--no-track"  # Don't track origin/HEAD
fi

if [ "$WORKTREE_MODE" -eq 1 ]; then
    # Get repository name and parent directory for worktree
    # Use the main worktree path to ensure consistent naming
    MAIN_WORKTREE=$(git worktree list --porcelain | head -n 1 | cut -d' ' -f2)
    REPO_NAME=$(basename "$MAIN_WORKTREE")
    PARENT_DIR=$(dirname "$MAIN_WORKTREE")
    WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${branchName}"

    if [ -d "$WORKTREE_DIR" ]; then
        echo "ERROR: Directory $WORKTREE_DIR already exists" 1>&2
        exit 1
    fi

    git worktree add -b "$branchName" "$WORKTREE_DIR" "$base_ref" $track_flag
    echo "Worktree created successfully. To switch:" 
    echo "cd $WORKTREE_DIR"
else
    # Checkout remote branch from where you want to update.
    git switch -c "$branchName" "$base_ref" $track_flag
fi
